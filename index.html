<!DOCTYPE html>
<html>
<head>
<title>점프 피하기 게임 (점프 시간 고려 간격)</title>
<style>
  body {
    background-color: #f0f0f0;
    background-image: url('background.png'); /* 배경 이미지 파일 경로 */
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    overflow: hidden; /* 전체 페이지 스크롤 및 줌 방지 */
    font-family: Arial, sans-serif;
  }

  #game-container {
    width: 1000px;
    height: 500px;
    border: 2px solid #333;
    background-color: rgba(255, 255, 255, 0.8);
    position: relative;
    overflow: hidden;
    cursor: pointer;
  }

  #player {
    width: 50px;
    height: 50px;
    background-image: url('player.png');
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center;
    position: absolute;
    bottom: 0;
    left: 100px;
    transition: filter 0.1s ease-out; /* 무적 상태 전환 시 부드러운 효과 */
  }

  /* 무적 상태일 때 플레이어 스타일 */
  #player.invincible {
    filter: brightness(2) saturate(1.5); /* 밝기와 채도 증가 효과 */
    animation: blink 0.3s infinite alternate; /* 깜빡임 효과 */
  }

  @keyframes blink {
    from { opacity: 1; }
    to { opacity: 0.5; }
  }


  .obstacle {
    background-image: url('obstacle.png');
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center;
    width: 30px;
    position: absolute;
    bottom: 0;
    right: -30px;
  }

  .flying-obstacle {
    background-image: url('flying_obstacle.png');
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center;
    border-radius: 0;
    position: absolute;
    right: -40px;
  }

  .bonus-item {
    background-image: url('invincibility_item.png'); /* 무적 아이템 이미지 파일 경로 */
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center;
    position: absolute;
    right: -50px;
  }


  #game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 4em;
    color: #333;
    display: none;
    text-align: center;
    z-index: 10;
    pointer-events: auto;
  }

  #restart-button {
    padding: 15px 30px;
    font-size: 1.5em;
    cursor: pointer;
    background-color: #28a716;
    color: white;
    border: none;
    border-radius: 5px;
    margin-top: 30px;
    display: none;
    pointer-events: auto;
  }

  #score {
    position: absolute;
    top: 20px;
    left: 20px;
    font-size: 2em;
    color: #333;
    z-index: 5;
  }
</style>
</head>
<body>

<audio id="bgMusic" src="background_music.mp3" loop preload="auto"></audio>
<audio id="jumpSound" src="jump_sound.mp3" preload="auto"></audio>
<audio id="gameOverSound" src="game_over_sound.mp3" preload="auto"></audio>


<div id="game-container">
  <div id="player"></div>
  <div id="game-over">
    게임 오버!
    <button id="restart-button">다시 시작</button>
  </div>
  <div id="score">점수: 0</div>
</div>

<script>
  const player = document.getElementById('player');
  const gameContainer = document.getElementById('game-container');
  const gameOverDisplay = document.getElementById('game-over');
  const restartButton = document.getElementById('restart-button');
  const scoreDisplay = document.getElementById('score');

  // 오디오 요소 가져오기
  const bgMusic = document.getElementById('bgMusic');
  const jumpSound = document.getElementById('jumpSound');
  const gameOverSound = document.getElementById('gameOverSound'); // 선택 사항

  let currentJumpCount = 0;
  const maxJumpLevel = 5;
  let playerBottom = 0;
  let playerVelocityY = 0;

  const gravity = 0.3;
  const jumpStrengths = [0, 10, 8, 6, 4, 2];

  let gameOver = false;
  let score = 0;
  let obstacleInterval;
  let obstacleSpeed = 2;

  // 난이도 관련 설정
  const initialObstacleSpeed = 2;
  const maxObstacleSpeed = 5;
  const speedIncreasePerScore = 0.1;

  // --- 장애물 생성 간격 (시간 단위 - 밀리초) 설정 수정 ---
  const initialObstacleInterval = 1500; // 초기 간격: 1.5초
  const minObstacleInterval = 1150;     // <<< 최소 간격: 1.15초 (점프/착지 시간 고려) >>>
  const intervalDecreasePerScore = 15;   // 점수당 감소량 (밀리초)
  let currentObstacleIntervalValue = initialObstacleInterval; // 현재 간격 저장 변수
  // --- 수정된 부분 끝 ---

  const initialMinGroundObstacleHeight = 50;
  const initialMaxGroundObstacleHeight = 150;
  const groundHeightIncreasePerScore = 5;
  let currentMaxGroundObstacleHeight = initialMaxGroundObstacleHeight;

  // 공중 장애물 관련 설정
  const flyingObstacleChance = 0.08;
  const minFlyingObstacleBottom = 80;
  const maxFlyingObstacleBottom = 300;

  const minFlyingObstacleSize = 30;
  const maxFlyingObstacleSize = 60;

  // 보너스 아이템 관련 설정
  const bonusItemChance = 0.03;
  const minBonusItemSize = 40;
  const maxBonusItemSize = 50;
  const minBonusItemBottom = 100;
  const maxBonusItemBottom = 250;
  const invincibilityDuration = 5000;

  let isInvincible = false;
  let invincibilityTimeoutId;

  let animationFrameId;
  let maxPlayerHeight;

  // 음악 재생 상태 플래그
  let bgMusicPlayedFirstTime = false;

  // 지상 장애물 카운트 추가 (높이 조절용)
  let groundObstacleCount = 0;

  // 모바일 기기 감지 함수
  function isMobile() {
    return /Mobi|Android/i.test(navigator.userAgent);
  }

  document.addEventListener('DOMContentLoaded', () => {
    maxPlayerHeight = gameContainer.offsetHeight - player.offsetHeight;
  });

  // 키보드 스페이스바 이벤트 리스너
  document.addEventListener('keydown', (event) => {
    if (event.code === 'Space' && !gameOver) {
      if (!bgMusicPlayedFirstTime) {
        tryPlayBgMusic();
      }
      if (currentJumpCount < maxJumpLevel) {
        startJump();
      }
    }
  });

  // 게임 컨테이너 터치 이벤트 리스너
  gameContainer.addEventListener('touchstart', (event) => {
    if (!bgMusicPlayedFirstTime) {
      tryPlayBgMusic();
    }

    if (!gameOver) {
      event.preventDefault();
      if (currentJumpCount < maxJumpLevel) {
        startJump();
        if (jumpSound) {
          jumpSound.currentTime = 0;
          jumpSound.play().catch(e => console.log("점프 사운드 재생 실패:", e));
        }
      }
    }
  }, { passive: false });

  // '다시 시작' 버튼 터치 이벤트 리스너
  restartButton.addEventListener('touchend', (event) => {
    event.preventDefault();
    if (gameOver) {
        startGame();
    }
  });

  // PC용 '다시 시작' 버튼 클릭 이벤트 리스너
  restartButton.addEventListener('click', () => {
    if (gameOver) {
        startGame();
    }
  });


  // 배경 음악 재생 시도 함수
  function tryPlayBgMusic() {
    if (bgMusic && !bgMusicPlayedFirstTime) {
      bgMusic.volume = 0.5;
      bgMusic.play()
        .then(() => {
          console.log("배경 음악 재생 성공!");
          bgMusicPlayedFirstTime = true;
        })
        .catch(e => {
          console.log("배경 음악 재생 실패 (사용자 상호작용 필요):", e);
        });
    }
  }


  function startJump() {
    currentJumpCount++;
    if (jumpStrengths.length > currentJumpCount) {
        playerVelocityY = jumpStrengths[currentJumpCount];
        playerBottom = parseFloat(player.style.bottom || 0);
        if (jumpSound) {
            jumpSound.currentTime = 0;
            jumpSound.play().catch(e => console.log("점프 사운드 재생 실패 (키보드):", e));
        }
    }
  }

  function gameLoop() {
    if (gameOver) {
      cancelAnimationFrame(animationFrameId);
      return;
    }

    playerBottom += playerVelocityY;
    playerVelocityY -= gravity;

    if (playerBottom < 0) {
      playerBottom = 0;
      playerVelocityY = 0;
      currentJumpCount = 0;
    }

    if (playerBottom > maxPlayerHeight) {
        playerBottom = maxPlayerHeight;
        if (playerVelocityY > 0) {
            playerVelocityY = 0;
        }
    }

    player.style.bottom = `${playerBottom}px`;

    animationFrameId = requestAnimationFrame(gameLoop);
  }


  function createObstacle() {
    if (gameOver) return;

    const element = document.createElement('div');
    gameContainer.appendChild(element);

    let currentElementWidth;
    let elementType;

    if (Math.random() < bonusItemChance) {
        elementType = 'item';
        element.classList.add('bonus-item');
        const randomItemSize = Math.random() * (maxBonusItemSize - minBonusItemSize) + minBonusItemSize;
        element.style.width = `${randomItemSize}px`;
        element.style.height = `${randomItemSize}px`;
        currentElementWidth = randomItemSize;

        const randomBottom = Math.random() * (maxBonusItemBottom - minBonusItemBottom) + minBonusItemBottom;
        element.style.bottom = `${randomBottom}px`;
    }
    else if (Math.random() < flyingObstacleChance) {
        elementType = 'obstacle';
        element.classList.add('flying-obstacle');

        const randomSize = Math.random() * (maxFlyingObstacleSize - minFlyingObstacleSize) + minFlyingObstacleSize;
        element.style.width = `${randomSize}px`;
        element.style.height = `${randomSize}px`;
        currentElementWidth = randomSize;

        const randomBottom = Math.random() * (maxFlyingObstacleBottom - minFlyingObstacleBottom) + minFlyingObstacleBottom;
        element.style.bottom = `${randomBottom}px`;
    } else {
        elementType = 'obstacle';
        element.classList.add('obstacle');
        groundObstacleCount++;

        const minHeight = initialMinGroundObstacleHeight;
        const middleHeight = (initialMinGroundObstacleHeight + currentMaxGroundObstacleHeight) / 2;
        let randomHeight;

        if (groundObstacleCount % 2 !== 0) {
            randomHeight = Math.random() * (middleHeight - minHeight) + minHeight;
        } else {
            randomHeight = Math.random() * (currentMaxGroundObstacleHeight - middleHeight) + middleHeight;
        }
        
        element.style.height = `${randomHeight}px`;
        element.style.bottom = '0px';
        currentElementWidth = 30;
    }


    let elementRight = -currentElementWidth;
    let elementAnimation;

    function moveElement() {
      if (gameOver) {
        cancelAnimationFrame(elementAnimation);
        return;
      }

      elementRight += obstacleSpeed;
      element.style.right = `${elementRight}px`;

      const playerRect = player.getBoundingClientRect();
      const elementRect = element.getBoundingClientRect();

      if (
        playerRect.right > elementRect.left &&
        playerRect.left < elementRect.right &&
        playerRect.bottom > elementRect.top &&
        playerRect.top < elementRect.bottom
      ) {
        if (elementType === 'obstacle') {
          if (!isInvincible) {
            endGame();
            return;
          } else {
            element.remove();
            cancelAnimationFrame(elementAnimation);
            return;
          }
        } else if (elementType === 'item') {
          activateInvincibility();
          element.remove();
          cancelAnimationFrame(elementAnimation);
          return;
        }
      }

      if (elementRight > gameContainer.offsetWidth + currentElementWidth) {
        element.remove();
        if (elementType === 'obstacle') {
            score++;
            scoreDisplay.textContent = `점수: ${score}`;
            adjustDifficulty();
        }
        return;
      }
      elementAnimation = requestAnimationFrame(moveElement);
    }
    elementAnimation = requestAnimationFrame(moveElement);
  }

  function activateInvincibility() {
    isInvincible = true;
    player.classList.add('invincible');

    if (invincibilityTimeoutId) {
      clearTimeout(invincibilityTimeoutId);
    }

    invincibilityTimeoutId = setTimeout(() => {
      isInvincible = false;
      player.classList.remove('invincible');
    }, invincibilityDuration);
  }


  function adjustDifficulty() {
    obstacleSpeed = Math.min(initialObstacleSpeed + (score * speedIncreasePerScore), maxObstacleSpeed);

    const newInterval = Math.max(initialObstacleInterval - (score * intervalDecreasePerScore), minObstacleInterval);

    if (obstacleInterval && newInterval !== currentObstacleIntervalValue) {
        currentObstacleIntervalValue = newInterval;
        clearInterval(obstacleInterval);
        obstacleInterval = setInterval(createObstacle, newInterval);
    }

    currentMaxGroundObstacleHeight = Math.min(initialMaxGroundObstacleHeight + (score * groundHeightIncreasePerScore), gameContainer.offsetHeight - player.offsetHeight - 20);
  }


  function startGame() {
    bgMusicPlayedFirstTime = false;
    groundObstacleCount = 0;

    gameOver = false;
    score = 0;
    scoreDisplay.textContent = `점수: 0`;
    gameOverDisplay.style.display = 'none';
    restartButton.style.display = 'none';

    isInvincible = false;
    player.classList.remove('invincible');
    if (invincibilityTimeoutId) {
        clearTimeout(invincibilityTimeoutId);
    }

    obstacleSpeed = initialObstacleSpeed;
    currentMaxGroundObstacleHeight = initialMaxGroundObstacleHeight;
    currentObstacleIntervalValue = initialObstacleInterval;

    playerBottom = 0;
    playerVelocityY = 0;
    currentJumpCount = 0;
    player.style.bottom = '0px';

    document.querySelectorAll('.obstacle, .flying-obstacle, .bonus-item').forEach(el => el.remove());

    if (obstacleInterval) {
        clearInterval(obstacleInterval);
    }
    obstacleInterval = setInterval(createObstacle, currentObstacleIntervalValue);

    cancelAnimationFrame(animationFrameId);
    gameLoop();
  }

  function endGame() {
    gameOver = true;
    gameOverDisplay.style.display = 'block';

    clearInterval(obstacleInterval);
    cancelAnimationFrame(animationFrameId);
    if (invincibilityTimeoutId) {
        clearTimeout(invincibilityTimeoutId);
    }

    if (bgMusic) {
      bgMusic.pause();
      bgMusic.currentTime = 0;
    }
    if (gameOverSound) {
      gameOverSound.currentTime = 0;
      gameOverSound.play().catch(e => console.log("게임 오버 사운드 재생 실패:", e));
    }

    if (isMobile()) {
      setTimeout(() => {
        if (gameOver) startGame();
      }, 1500);
    } else {
      restartButton.style.display = 'inline-block';
    }
  }

  // 게임 초기 시작
  startGame();

</script>
</body>
</html>